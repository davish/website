#+title: Hotwiring Django: Adapting Rails's New Magic
#+date: 2020-12-22T19:38:55-04:00
#+description: A quick survey of the state of web development in 2020, and a dive into some very new developments.
#+slug: Hotwiring Django
#+draft: false
#+tags[]: django webdev hotwire turbo

* What is Hotwire?
[[https://hotwire.dev][Hotwire]], which seems to be short for (H)tml (O)ver (T)he (Wire), is a collection of frameworks just announced today by Basecamp that work together to help build "traditional" server-rendered web applications that look and feel to users like modern, Single-Page Applications (SPAs) like those built in React, Vue or Svelte. At its core is [[https://turbo.hotwire.dev][Turbo]], a new library that takes HTML from AJAX requests and dynamically modifies the currrent page. It comes out of an existing library called Turbolinks, now called "[[https://turbo.hotwire.dev/handbook/drive][Turbo Drive]]" as of today, which is a utility that intercepts all click events on anchor tags, loads the resources over AJAX, and swaps out the =<body>= tags, all while handling browser history.

"[[https://turbo.hotwire.dev/handbook/frames][Turbo Frames]]" one of the new components, is a super interesting concept. Turbo Drive will still AJAX-ify form submissions and link clicks behind the scenes, but instead of swapping out the entire webpage each time, Turbo will look for matching =<turbo-frame>= tags on the current page and in the new page's content. If there's a match, it'll /dynamically replace that section of the page/. This allows you to replace your React components and your JSON serialization code completely with server-rendered templates. Basically, you can compose webpages together, using =<turbo-frame>= to delineate components in your template partials, similarly to how you'd think of a React app. The benefit here being that all the logic is handled on the server-side.
* Now, why go through all the trouble not to use React?
Building a web app is always going to be a complex endeavour. SPA view libraries like React have emerged in the past five or so years as an awesome way to handle that complexity on the client side, allowing developers to build interactive user-interfaces in a composable way, re-using components easily in different parts of the site.
** The Status Quo
Generally, when building a React app, you get any dynamic data through a loosely coupled JSON API (in my case, probably written with [[https://www.django-rest-framework.org][Django REST Framework]]). If you're using a web framework like Django or Ruby on Rails, then you're going to have a lot of complexity and business logic on both the frontend and backend. Whenever you add a feature, you need to ask yourself where it should be added. The loose coupling between parts that may very well be written in different languages means that it's really difficult to share code, and even if you're doing something as simple as validating a form, you'll probably end up with a decent amount of duplicated business logic, a big no-no if you follow the [[https://en.wikipedia.org/wiki/Don%27t_repeat_yourself][DRY principle]]!
** Managing Complexity
There's a bunch of different solutions to this problem, and they fall broadly into two separate categories.
*** Frontend-First: The JAMStack
In recent years, there's been a big push towards the [[https://jamstack.org/what-is-jamstack/][JAMStack]]: pushing all your complexity and business logic onto your frontend, and relying mostly on commodified API services for your backend work. That's certainly one way to think about your apps, and if you're mostly comfortable in React with a framework like NextJS, it's a good option! But there are certainly other approaches.
*** Backend-First: A more crowded field.
Many people, myself included, enjoy modeling business logic in the ways backend frameworks allow! Traditional "batteries included" frameworks like Rails and Django have been around for over a decade now, and are still a way to build organized, dynamic web applications. However loading a new page in the browser for every action feels a lot slower than whizzing through an SPA, so can be difficult to build server-only apps that feel as good to users as SPAs.

Backend-first, modern web frameworks have begun to proliferate. [[https://www.phoenixframework.org/blog/build-a-real-time-twitter-clone-in-15-minutes-with-live-view-and-phoenix-1-5][Phoenix LiveView]] and [[https://laravel-livewire.com][Laravel Livewire]] are two that come to mind immediately. Yesterday, the React Core team at Facebook threw their hat in the ring, with their [[https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html][Server Components]] that start to give React a bit of a backend/full-stack flair.

The folks at Basecamp, the company behind Hotwire, have always been skeptical of thick clients with loads of JavaScript, which makes sense, considering their [[https://twitter.com/dhh][CTO]] is the creator of Ruby on Rails. Hotwire is Basecamp's latest answer to the challenge of building modern, responsive, "snappy" single-page applications where the domain logic lives entirely on the server.
** As the Pendulum Swings
We started the decade with frameworks like [[https://www.meteor.com][Meteor.js]] with extremely tight couplings between the client and server, and after a long time wandering in the wilderness of duplicated compelxity across loosely-coupled frontend and backend, it seems like we're entering the 20's with a renewed push towards a [[https://m.signalvnoise.com/the-majestic-monolith/][more monolithic]] approach to web development. When even a frontend framework like React is beginning to bridge the gap with the backend, you know it's an interesting idea to explore right now.
* Trying out Hotwire with Django
Since the push behind Hotwire came from DHH and Basecamp, it makes sense that their examples are with Ruby on Rails, and that's where they've made their supporting libraries. But there's really nothing tying Turbo to Rails at all. It's a JavaScript library that you plop into your page's =<head>=, and it expects specific HTML returned on requests. I decided to take a shot at building a demo app similar to what's shown in Hotwire's demo video using Django rather than Rails. [[https://github.com/davish/hotwire-django-demo-chat][It really didn't take long!]] I got my start in Web Development with a JQuery app with a REST API, and even after moving on to Django, I always used Django REST Framework. I never really took advantage of the templating functionality, or the super-useful built-in CRUD operations with Django forms. It was an interesting experience working with =CreateView= and =DetailView= rather than =ModelViewSet=, and I'll be excited to keep exploring this going forward.

After an hour or so more of experimentation and digging into the turbo-rails codebase, I got a working prototype of a Turbo Streams integration for Django! I'm working on [[https://github.com/pennlabs/django-rest-live][something similar for Django REST Framework]] right now, which definitely helped in hitting the ground running. It only works for =append= actions right now, and it requires you to specify which fields you want to allow streaming by. But it does allow for a full reltime chat demo with Hotwire and Django! I'll probably look to clean up the code and make sure it works for the other actions.
